<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <title>Neon Wave | Modern Arcade & Cybernetics - BITSTART.CLUB</title>
    <meta name="description" content="Master the flow in Neon Wave. A high-speed procedural arcade experience. No registration, pure performance at BITSTART.CLUB.">
    <meta name="keywords" content="neon wave, arcade game, cyberwave, rhythm game, procedural game, bitstart club">
    <link rel="canonical" href="https://bitstart.club/modern/wave.html">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --modern-pink: #ec4899;
            --bg-deep: #050010;
        }

        body { font-family: 'Inter', sans-serif; background: #0b0f1a; color: #f3f4f6; overflow-x: hidden; }
        .font-game { font-family: 'Orbitron', sans-serif; }
        .glass-card { background: rgba(30, 41, 59, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .neon-text { text-shadow: 0 0 10px rgba(236, 72, 153, 0.8); }
        .neon-border { border: 2px solid var(--modern-pink); box-shadow: 0 0 15px rgba(236, 72, 153, 0.4); }
        .ad-placeholder { border: 1px dashed rgba(236, 72, 153, 0.3); background: rgba(15, 23, 42, 0.5); }
        
        .game-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            aspect-ratio: 16 / 9;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .scanlines {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(236, 72, 153, 0.03) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }

        .game-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(5, 0, 16, 0.9);
            z-index: 100;
            text-align: center;
        }

        #mute-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 110;
            font-size: 10px;
            font-weight: bold;
            pointer-events: auto;
            border-radius: 4px;
            transition: all 0.2s;
        }

        #mute-btn:hover {
            background: #0ff;
            color: #000;
        }

        @media (max-height: 850px) {
            .history-section { margin-top: 1.5rem; }
            .main-content { padding-top: 0.5rem; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <header class="bg-[#0f172a]/80 border-b border-indigo-900/50 z-50 backdrop-blur-md header-nav">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <a class='text-2xl md:text-3xl font-black font-game text-indigo-500 tracking-widest neon-text' href='/'>BITSTART<span class="text-white">.CLUB</span></a>
            <nav class="hidden md:flex space-x-8">
                <a class='text-sm font-bold uppercase hover:text-indigo-400 transition' href='/'>Home</a>
                <a class='text-sm font-bold uppercase hover:text-indigo-400 transition' href='/learning'>Learning</a>
                <a class='text-sm font-bold uppercase text-green-400' href='/classic'>Classic</a>
                <a class='text-sm font-bold uppercase hover:text-indigo-400 transition' href='/modern'>Modern</a>
            </nav>
        </div>
    </header>

    <main class="flex-grow container mx-auto px-2 md:px-4 py-4 main-content">
        <div class="flex flex-col lg:flex-row gap-6">
            
            <div class="flex-grow">
                <div class="glass-card p-3 md:p-6 rounded-3xl neon-border relative mb-6">
                    
                    <div class="flex justify-around mb-4 font-game">
                        <div class="text-center">
                            <div class="text-[10px] text-gray-500 uppercase tracking-tighter">Sync Progress</div>
                            <div class="text-3xl md:text-4xl font-black text-[#ec4899]" id="scoreDisplay">0%</div>
                        </div>
                        <div class="text-center">
                            <div class="text-[10px] text-gray-500 uppercase tracking-tighter">Session Time</div>
                            <div class="text-3xl md:text-4xl font-black text-cyan-400" id="timeDisplay">0.0s</div>
                        </div>
                        <div class="text-center">
                            <div class="text-[10px] text-gray-500 uppercase tracking-tighter">Best Sync</div>
                            <div class="text-3xl md:text-4xl font-black text-indigo-400" id="bestScoreDisplay">0%</div>
                        </div>
                    </div>

                    <div class="game-wrapper border border-white/5">
                        <div class="scanlines"></div>
                        <button id="mute-btn">SOUND: ON</button>
                        <canvas id="gameCanvas"></canvas>
                        
                        <div id="startOverlay" class="game-overlay p-6">
                            <h2 class="text-4xl font-game font-black text-[#ec4899] mb-2 uppercase neon-text">Neon Wave</h2>
                            <p class="text-gray-400 text-xs mb-8 uppercase tracking-widest">Hold to Ascend • Release to Descend</p>
                            <button id="startBtn" class="bg-pink-600 hover:bg-pink-500 text-white font-game font-bold px-10 py-3 rounded-2xl transition uppercase shadow-lg shadow-pink-500/20">Initialize</button>
                        </div>

                        <div id="endOverlay" class="game-overlay p-6 hidden">
                            <h2 id="endTitle" class="text-3xl font-game font-bold text-[#ec4899] mb-2 uppercase">System Crash</h2>
                            <p id="endStats" class="text-white mb-4 font-bold uppercase text-sm"></p>
                            <p id="endTime" class="text-gray-400 mb-6 text-xs uppercase tracking-wider"></p>
                            <button id="restartBtn" class="bg-white text-black font-game font-bold px-10 py-3 rounded-2xl hover:bg-pink-400 transition uppercase">Reboot</button>
                        </div>
                    </div>

                    <p class="mt-4 text-[10px] text-gray-500 uppercase tracking-widest text-center">
                        Spacebar or Touch to Control Buoyancy<br>
                        Navigate the neural corridors
                    </p>
                </div>

                <div class="glass-card p-6 md:p-8 rounded-3xl border border-white/5 history-section">
                    <h2 class="text-xl md:text-2xl font-game font-bold text-indigo-400 mb-6 uppercase tracking-wider">The Mechanics of Flow</h2>
                    <div class="space-y-4 text-gray-300 leading-relaxed text-sm">
                        <p>
                            <strong>Neon Wave: Ultimate Edition</strong> combines the best elements of high-velocity arcade design. This version features enhanced collision detection with a 4-point hitbox system, ensuring precise and fair gameplay.
                        </p>
                        <p>
                            The procedural generation algorithm has been upgraded with dynamic obstacle spawning, including vertical pillars and alternating spike patterns. A cooldown system prevents unfair clustering while maintaining difficulty progression throughout the 1500-tile journey.
                        </p>
                        <div class="bg-black/30 p-4 rounded-xl border-l-4 border-pink-500 my-4">
                            <p class="italic text-xs text-gray-400 text-justify">
                                Tech Insight: The Ultimate Edition features a minimum tunnel height validator (3 tiles) that prevents impossible passages, combined with an ambient audio layer that pulses every 2 seconds to enhance immersion.
                            </p>
                        </div>
                        <p>
                            At BITSTART.CLUB, we've optimized the physics engine with smooth camera interpolation (lerp coefficient: 0.15) and vertical clamping, creating the perfect balance between challenge and playability for entering the flow state.
                        </p>
                    </div>
                </div>
            </div>

            <aside class="w-full lg:w-1/4 space-y-6">
                <div class="ad-placeholder h-40 flex items-center justify-center rounded-3xl">
                    <span class="text-pink-900 font-bold uppercase tracking-widest text-[10px]">Top Sidebar Ad</span>
                </div>

                <div class="glass-card p-6 rounded-3xl border border-pink-900/50">
                    <h3 class="font-game text-xs font-bold text-[#ec4899] mb-4 uppercase">Modern Library</h3>
                    <ul class="space-y-3 text-sm">
                        <li class="flex items-center gap-2 text-[#ec4899] font-bold"><div class="w-1.5 h-1.5 rounded-full bg-pink-500"></div> Neon Wave: Ultimate</li>
                        <li><a class='hover:text-pink-400 transition' href='#'>Vector Dash</a></li>
                        <li><a href="#" class="text-gray-600 cursor-not-allowed">Neural Runner</a></li>
                    </ul>
                </div>

                <div class="glass-card p-6 rounded-3xl border border-indigo-900/50">
                    <h4 class="text-xs font-bold uppercase text-indigo-400 mb-2">Cognitive Value</h4>
                    <p class="text-[10px] text-gray-500 leading-tight">
                        Neon Wave: Ultimate Edition enhances visual processing speed, spatial reaction time, and decision-making under pressure. The 4-point collision system trains pattern recognition while the ambient audio layer improves rhythm synchronization.
                    </p>
                </div>

                <div class="ad-placeholder h-64 flex items-center justify-center rounded-3xl">
                    <span class="text-pink-900 font-bold uppercase tracking-widest text-[10px]">Square Ad Unit</span>
                </div>
            </aside>
        </div>
    </main>

    <footer class="bg-[#0f172a] border-t border-indigo-900/50 py-8 mt-12">
        <div class="container mx-auto px-4 text-center">
            <div class="flex justify-center space-x-6 md:space-x-8 text-[9px] font-bold uppercase tracking-widest text-gray-500 mb-6">
                <a class='hover:text-green-400 transition' href='/privacy'>Privacy</a>
                <a class='hover:text-green-400 transition' href='/terms'>Terms</a>
                <a href="../contact.html" class="hover:text-green-400 transition">Support</a>
            </div>
            <p class="text-[9px] text-gray-800 uppercase tracking-[0.3em]">© 2026 BITSTART.CLUB • THE NO-DATA ZONE</p>
        </div>
    </footer>

    <script>
        /**
         * BITSTART.CLUB - Neon Wave: Ultimate Edition
         * Combines best features from both versions:
         * - 4-point collision system (Version 2)
         * - Ambient audio layer (Version 2)
         * - Dynamic obstacle generation with cooldown (Version 2)
         * - Smooth camera with clamping (Version 2)
         * - Long level design (Version 1)
         * - BITSTART.CLUB UI/branding (Version 1)
         */
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startOverlay = document.getElementById('startOverlay');
        const endOverlay = document.getElementById('endOverlay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const bestScoreDisplay = document.getElementById('bestScoreDisplay');

        // Аудіосистема з ambient layer
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isMuted = false;

        const Sound = {
            play(freq, type, dur, vol = 0.05) {
                if (isMuted || audioCtx.state === 'suspended') return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + dur);
            },
            
            playAmbient() {
                if (isMuted || gameState !== 'PLAYING') return;
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(55, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.02, audioCtx.currentTime);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                setTimeout(() => osc.stop(), 500);
            },

            playJump() {
                if (isMuted) return;
                this.play(300, 'sine', 0.1);
            },

            playCrash() {
                if (isMuted) return;
                this.play(100, 'sawtooth', 0.4, 0.1);
            },

            playWin() {
                if (isMuted) return;
                this.play(440, 'sine', 0.2);
                setTimeout(() => this.play(554, 'sine', 0.2), 150);
                setTimeout(() => this.play(659, 'sine', 0.4), 300);
            }
        };

        document.getElementById('mute-btn').addEventListener('click', (e) => {
            isMuted = !isMuted;
            e.target.innerText = isMuted ? "SOUND: OFF" : "SOUND: ON";
        });

        const CONFIG = {
            TILE_SIZE: 40,
            SPEED_X: 7,
            SPEED_Y: 7,
            LEVEL_HEIGHT: 22,
            LEVEL_LENGTH: 1500,
            TRAIL_MAX: 20,
            CAM_OFFSET_X: 250
        };

        const TILE = { EMPTY: 0, BLOCK: 1, SPIKE_UP: 2, SPIKE_DOWN: 3, FINISH: 9 };
        
        let levelMap = [];
        let player = null; 
        let camera = { x: 0, y: 0 };
        let gameState = 'MENU';
        let frame = 0;
        let particles = [];
        let startTime = 0;
        let bestScore = localStorage.getItem('waveBestScore') || 0;
        bestScoreDisplay.innerText = `${bestScore}%`;

        // Покращена генерація рівня з динамічними перешкодами
        function generateLevel() {
            levelMap = Array.from({ length: CONFIG.LEVEL_LENGTH }, () => 
                new Array(CONFIG.LEVEL_HEIGHT).fill(TILE.EMPTY)
            );
            
            let currentCeil = 4;
            let currentFloor = 16;
            let obstacleCooldown = 0;

            for (let x = 0; x < CONFIG.LEVEL_LENGTH; x++) {
                levelMap[x][0] = TILE.BLOCK;
                levelMap[x][CONFIG.LEVEL_HEIGHT - 1] = TILE.BLOCK;

                if (x > 30 && x < CONFIG.LEVEL_LENGTH - 40) {
                    const diff = x / CONFIG.LEVEL_LENGTH;
                    const tunnelH = Math.max(5, Math.floor(11 - diff * 6));
                    
                    if (x % 5 === 0) {
                        currentCeil += Math.floor((Math.random() - 0.5) * 4);
                        currentCeil = Math.max(1, Math.min(CONFIG.LEVEL_HEIGHT - tunnelH - 2, currentCeil));
                        currentFloor = currentCeil + tunnelH;
                    }
                    
                    for (let y = 1; y < CONFIG.LEVEL_HEIGHT - 1; y++) {
                        if (y < currentCeil || y > currentFloor) {
                            levelMap[x][y] = TILE.BLOCK;
                        }
                    }

                    // Динамічні перешкоди з cooldown
                    obstacleCooldown--;
                    if (obstacleCooldown <= 0 && Math.random() < 0.15 + diff * 0.3) {
                        obstacleCooldown = Math.floor(Math.random() * 10) + 5;
                        
                        let freeSpaceStart = -1, freeSpaceEnd = -1;
                        for(let y = 1; y < CONFIG.LEVEL_HEIGHT - 1; y++) {
                            if(levelMap[x][y] === TILE.EMPTY) {
                                if(freeSpaceStart === -1) freeSpaceStart = y;
                                freeSpaceEnd = y;
                            }
                        }

                        if (freeSpaceStart !== -1) {
                            const freeHeight = freeSpaceEnd - freeSpaceStart;
                            if (freeHeight < 3) continue; // Захист від непрохідних секцій

                            const type = Math.random();
                            if (type < 0.3 && freeHeight > 4) {
                                const mid = Math.floor((freeSpaceStart + freeSpaceEnd) / 2);
                                levelMap[x][mid] = TILE.BLOCK;
                            } else if (type < 0.65) {
                                levelMap[x][freeSpaceEnd] = TILE.SPIKE_UP;
                            } else {
                                levelMap[x][freeSpaceStart] = TILE.SPIKE_DOWN;
                            }
                        }
                    }
                }

                if (x >= CONFIG.LEVEL_LENGTH - 15) {
                    for (let y = 1; y < CONFIG.LEVEL_HEIGHT - 1; y++) {
                        levelMap[x][y] = TILE.FINISH;
                    }
                }
            }
        }

        function initCanvas() {
            const wrapper = canvas.parentElement;
            if (wrapper) {
                canvas.width = wrapper.clientWidth;
                canvas.height = wrapper.clientHeight;
            }
        }

        function resetGameState() {
            player = { 
                x: 200, 
                y: (CONFIG.LEVEL_HEIGHT / 2) * CONFIG.TILE_SIZE, 
                dy: 0, 
                trail: [], 
                input: false,
                radius: 10
            };
            camera = { x: 0, y: 0 };
            particles = [];
            startTime = Date.now();
        }

        function startGame() {
            resetGameState();
            gameState = 'PLAYING';
            startOverlay.classList.add('hidden');
            endOverlay.classList.add('hidden');
            generateLevel();
            Sound.play(440, 'sine', 0.5);
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function update() {
            if (gameState !== 'PLAYING' || !player) return;

            // Ambient loop кожні 2 секунди (120 frames @ 60fps)
            if (frame % 120 === 0) {
                Sound.playAmbient();
            }

            player.x += CONFIG.SPEED_X;
            player.dy = player.input ? -CONFIG.SPEED_Y : CONFIG.SPEED_Y;
            player.y += player.dy;

            if (frame % 2 === 0) {
                player.trail.push({ x: player.x, y: player.y });
                if (player.trail.length > CONFIG.TRAIL_MAX) player.trail.shift();
            }

            // Покращена камера з clamping
            camera.x = player.x - CONFIG.CAM_OFFSET_X;
            const levelPixelHeight = CONFIG.LEVEL_HEIGHT * CONFIG.TILE_SIZE;
            const targetY = player.y - canvas.height / 2;
            camera.y += (targetY - camera.y) * 0.15;
            
            if (camera.y < -canvas.height * 0.2) camera.y = -canvas.height * 0.2;
            if (camera.y > levelPixelHeight - canvas.height * 0.8) {
                camera.y = levelPixelHeight - canvas.height * 0.8;
            }

            // 4-точкова система колізій
            checkCollisions();

            const prog = Math.floor((player.x / (CONFIG.LEVEL_LENGTH * CONFIG.TILE_SIZE)) * 100);
            scoreDisplay.innerText = `${Math.min(100, prog)}%`;
            
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            timeDisplay.innerText = `${elapsed}s`;

            frame++;
        }

        function checkCollisions() {
            if (player.y < 0 || player.y > CONFIG.LEVEL_HEIGHT * CONFIG.TILE_SIZE) {
                die();
                return;
            }

            const hitBoxSize = player.radius * 0.7;
            const points = [
                {x: player.x + hitBoxSize, y: player.y},
                {x: player.x - hitBoxSize, y: player.y - hitBoxSize},
                {x: player.x - hitBoxSize, y: player.y + hitBoxSize},
                {x: player.x + hitBoxSize, y: player.y - hitBoxSize}
            ];

            for (let p of points) {
                const tx = Math.floor(p.x / CONFIG.TILE_SIZE);
                const ty = Math.floor(p.y / CONFIG.TILE_SIZE);

                if (tx >= 0 && tx < CONFIG.LEVEL_LENGTH && ty >= 0 && ty < CONFIG.LEVEL_HEIGHT) {
                    const tile = levelMap[tx][ty];
                    if (tile === TILE.BLOCK || tile === TILE.SPIKE_UP || tile === TILE.SPIKE_DOWN) {
                        die();
                        return;
                    }
                    if (tile === TILE.FINISH) {
                        win();
                        return;
                    }
                }
            }
        }

        function die() {
            gameState = 'OVER';
            Sound.playCrash();
            const currentProg = parseInt(scoreDisplay.innerText);
            const survivalTime = ((Date.now() - startTime) / 1000).toFixed(2);
            
            if (currentProg > bestScore) {
                bestScore = currentProg;
                localStorage.setItem('waveBestScore', bestScore);
                bestScoreDisplay.innerText = `${bestScore}%`;
            }
            
            createExplosion(player.x, player.y, 100, '#ec4899');
            
            document.getElementById('endTitle').innerText = "System Crash";
            document.getElementById('endStats').innerText = `Sync Lost at ${currentProg}%`;
            document.getElementById('endTime').innerText = `Session Duration: ${survivalTime}s`;
            endOverlay.classList.remove('hidden');
        }

        function win() {
            gameState = 'OVER';
            Sound.playWin();
            const survivalTime = ((Date.now() - startTime) / 1000).toFixed(2);
            
            scoreDisplay.innerText = "100%";
            localStorage.setItem('waveBestScore', 100);
            bestScoreDisplay.innerText = "100%";
            
            document.getElementById('endTitle').innerText = "System Breached";
            document.getElementById('endStats').innerText = "Encryption fully bypassed";
            document.getElementById('endTime').innerText = `Completion Time: ${survivalTime}s`;
            endOverlay.classList.remove('hidden');
        }

        function createExplosion(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 20 + 5;
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.5,
                    color: color,
                    size: Math.random() * 6 + 2
                });
            }
            if (particles.length > 300) particles.splice(0, particles.length - 300);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!player) return;

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            const startX = Math.floor(camera.x / CONFIG.TILE_SIZE);
            const endX = startX + Math.ceil(canvas.width / CONFIG.TILE_SIZE) + 2;

            // Малювання тайлів
            for (let x = startX; x < endX; x++) {
                if (!levelMap[x]) continue;
                for (let y = 0; y < CONFIG.LEVEL_HEIGHT; y++) {
                    const tile = levelMap[x][y];
                    if (tile === TILE.EMPTY) continue;
                    const px = x * CONFIG.TILE_SIZE;
                    const py = y * CONFIG.TILE_SIZE;

                    if (tile === TILE.BLOCK) {
                        ctx.strokeStyle = 'rgba(236, 72, 153, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px + 1, py + 1, CONFIG.TILE_SIZE - 2, CONFIG.TILE_SIZE - 2);
                    } else if (tile === TILE.SPIKE_UP || tile === TILE.SPIKE_DOWN) {
                        ctx.fillStyle = '#ec4899';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ec4899';
                        ctx.beginPath();
                        if (tile === TILE.SPIKE_UP) {
                            ctx.moveTo(px, py + CONFIG.TILE_SIZE);
                            ctx.lineTo(px + CONFIG.TILE_SIZE / 2, py);
                            ctx.lineTo(px + CONFIG.TILE_SIZE, py + CONFIG.TILE_SIZE);
                        } else {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + CONFIG.TILE_SIZE / 2, py + CONFIG.TILE_SIZE);
                            ctx.lineTo(px + CONFIG.TILE_SIZE, py);
                        }
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else if (tile === TILE.FINISH) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                        ctx.fillRect(px, py, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    }
                }
            }

            // Частинки
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.96;
                p.vy *= 0.96;
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.shadowBlur = 15 * p.life;
                    ctx.shadowColor = p.color;
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
            }

            // Гравець та trail
            if (gameState === 'PLAYING' || gameState === 'OVER') {
                if (player.trail && player.trail.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ec4899';
                    ctx.lineWidth = 4;
                    ctx.moveTo(player.trail[0].x, player.trail[0].y);
                    player.trail.forEach((t, i) => {
                        ctx.globalAlpha = i / player.trail.length;
                        ctx.lineTo(t.x, t.y);
                    });
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }

                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0ff';
                ctx.fillStyle = '#0ff';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Обробка подій
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState === 'PLAYING') {
                e.preventDefault();
                if (!player.input) {
                    player.input = true;
                    Sound.playJump();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && gameState === 'PLAYING') {
                player.input = false;
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'PLAYING') {
                player.input = true;
                Sound.playJump();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameState === 'PLAYING') {
                player.input = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === 'PLAYING') {
                player.input = true;
                Sound.playJump();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState === 'PLAYING') {
                player.input = false;
            }
        });

        window.addEventListener('resize', initCanvas);

        // Ініціалізація
        initCanvas();
        generateLevel();
        gameLoop();
    </script>
</body>
</html>
